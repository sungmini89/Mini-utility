# JSON Formatter/Validator 개발 기술블로그

## 🚀 프로젝트 개요

React 18 + TypeScript + Tailwind CSS + Vite를 활용하여 개발한 JSON Formatter/Validator의 기술적 구현 과정과 트러블슈팅 경험을 공유합니다.

## 1. 프로젝트 구조 분석

### 1.1 전체 아키텍처

```
json-formatter/
├── 📁 src/
│   ├── 📄 main.tsx              # React 앱 진입점
│   ├── 📄 App.tsx               # 메인 앱 컴포넌트
│   ├── 📁 components/
│   │   └── 📁 JsonFormatter/    # 핵심 기능 컴포넌트
│   ├── 📁 hooks/                # 커스텀 훅들
│   ├── 📁 utils/                # 유틸리티 함수들
│   ├── 📁 pages/                # 페이지 컴포넌트
│   └── 📁 __mocks__/            # 테스트용 모킹
├── 📄 vite.config.ts            # Vite 설정
├── 📄 tailwind.config.cjs       # Tailwind CSS 설정
├── 📄 jest.config.cjs           # Jest 테스트 설정
└── 📄 tsconfig.json             # TypeScript 설정
```

### 1.2 기술 스택 선택 이유

- **React 18**: Concurrent Features와 Suspense 활용
- **TypeScript**: 타입 안전성과 개발자 경험 향상
- **Tailwind CSS**: 빠른 UI 개발과 일관된 디자인 시스템
- **Vite**: 빠른 개발 서버와 최적화된 빌드
- **Jest**: React Testing Library와 함께 견고한 테스트 환경

## 2. 상태 관리 흐름 추적

### 2.1 상태 관리 아키텍처

```typescript
// JsonFormatter 컴포넌트의 상태 구조
const [input, setInput] = useLocalStorage<string>("jsonFormatter:input", "");
const [view, setView] = useState<
  "formatted" | "minified" | "yaml" | "csv" | "jsonpath"
>("formatted");
const [output, setOutput] = useState<string>("");
const [parseError, setParseError] = useState<ParseError | null>(null);
const [jsonValue, setJsonValue] = useState<any>(null);
const [jsonPathResult, setJsonPathResult] = useState<any>(null);
const [treeOpen, setTreeOpen] = useState<boolean>(false);
const [history, setHistory] = useLocalStorage<HistoryItem[]>(
  "jsonFormatter:history",
  []
);
const [loading, setLoading] = useState<boolean>(false);
const [toast, setToast] = useState<{
  message: string;
  type: "success" | "error";
} | null>(null);
```

### 2.2 상태 흐름 다이어그램

```
사용자 입력 → input 상태 변경 → useEffect 트리거 → JSON 검증 → 결과 처리 → output 상태 업데이트 → UI 렌더링
     ↓
히스토리 저장, 토스트 표시, 트리 뷰 업데이트
```

### 2.3 커스텀 훅 활용

- **useLocalStorage**: 입력값과 히스토리 영속성
- **useClipboard**: 클립보드 복사 기능
- **useDarkMode**: 시스템 테마 감지 및 적용

## 3. 중요 유틸 함수 하나씩 이해

### 3.1 validateJSON - JSON 유효성 검사

```typescript
export function validateJSON(input: string): {
  valid: boolean;
  value?: any;
  error?: ParseError;
} {
  if (!input.trim()) {
    return { valid: false, error: { message: "Input is empty" } };
  }
  try {
    const value = JSON.parse(input);
    return { valid: true, value };
  } catch (err: unknown) {
    const msg: string = err instanceof Error ? err.message : "Invalid JSON";
    let index: number | undefined;
    const match = msg.match(/position\s+(\d+)/i);
    if (match) {
      index = parseInt(match[1], 10);
    }
    return { valid: false, error: { message: msg, index } };
  }
}
```

**핵심 포인트**:

- 빈 입력 처리
- try-catch로 안전한 파싱
- 정규식으로 오류 위치 추출
- unknown 타입으로 타입 안전성 확보

### 3.2 jsonToYAML - JSON을 YAML로 변환

```typescript
export function jsonToYAML(value: any): string {
  try {
    return YAML.stringify(value);
  } catch (err: unknown) {
    const errorMessage =
      err instanceof Error ? err.message : "Unknown error occurred";
    throw new Error(`Failed to convert to YAML: ${errorMessage}`);
  }
}
```

**핵심 포인트**:

- 외부 라이브러리(yaml) 활용
- 에러 처리 및 사용자 친화적 메시지
- 타입 안전성 고려

### 3.3 applyJSONPath - JSONPath 쿼리 실행

```typescript
export function applyJSONPath(value: any, path: string): any {
  try {
    return JSONPath({ path, json: value });
  } catch (err: unknown) {
    const errorMessage =
      err instanceof Error ? err.message : "Unknown error occurred";
    throw new Error(`Failed to apply JSONPath: ${errorMessage}`);
  }
}
```

**핵심 포인트**:

- jsonpath-plus 라이브러리 활용
- 동적 경로 처리
- 에러 상황 대응

## 4. 메인 컴포넌트 흐름 추적

### 4.1 컴포넌트 생명주기

```typescript
const JsonFormatter: React.FC = () => {
  // 1. 상태 초기화
  const [input, setInput] = useLocalStorage<string>("jsonFormatter:input", "");

  // 2. 부수 효과 처리
  useEffect(() => {
    setLoading(true);
    const res = validateJSON(input);
    if (!res.valid) {
      setParseError(res.error || null);
      // ... 에러 처리
      return;
    }
    // ... 성공 처리
    setLoading(false);
  }, [input, view, jsonPath]);

  // 3. 이벤트 핸들러
  const handleCopy = async () => { /* 복사 로직 */ };
  const handleDownload = () => { /* 다운로드 로직 */ };
  const saveToHistory = () => { /* 히스토리 저장 로직 */ };

  // 4. 렌더링
  return (/* JSX */);
};
```

### 4.2 데이터 흐름

1. **입력 단계**: 사용자가 JSON 입력 → input 상태 업데이트
2. **검증 단계**: useEffect에서 JSON 유효성 검사
3. **변환 단계**: 선택된 뷰에 따라 데이터 변환
4. **출력 단계**: 결과를 output 상태에 저장
5. **UI 업데이트**: React가 자동으로 컴포넌트 리렌더링

## 5. 렌더링 최적화 포인트

### 5.1 useMemo 활용

```typescript
// validationResult를 useMemo로 최적화
const validationResult = useMemo(() => {
  return validateJSON(input);
}, [input]);
```

### 5.2 useCallback 활용

```typescript
// 이벤트 핸들러를 useCallback으로 최적화
const handleCopy = useCallback(async () => {
  // 복사 로직
}, [view, output, jsonPathResult]);
```

### 5.3 조건부 렌더링

```typescript
// 조건부 렌더링으로 불필요한 DOM 생성 방지
{
  view === "jsonpath" && (
    <div className="mb-2">
      <label className="text-sm font-medium mr-2">JSONPath:</label>
      <input /* ... */ />
    </div>
  );
}
```

### 5.4 가상화 고려사항

- 대용량 JSON 처리 시 가상 스크롤링 적용 가능
- 트리 뷰에서 깊은 중첩 구조 처리 최적화

## 6. 내가 개선한 부분

### 6.1 다크모드 스타일링 개선

**문제**: 다크모드에서 입력창 텍스트가 보이지 않음
**해결**: Tailwind CSS 클래스로 명시적 스타일링

```typescript
className =
  "p-2 border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100 placeholder-gray-500 dark:placeholder-gray-400 min-h-40 resize-y focus:outline-none focus:ring focus:ring-blue-500 dark:focus:ring-blue-400 w-full";
```

### 6.2 에러 처리 강화

**문제**: try-catch에서 any 타입 사용
**해결**: unknown 타입과 타입 가드 활용

```typescript
} catch (err: unknown) {
  const errorMessage = err instanceof Error ? err.message : "Unknown error occurred";
  throw new Error(`Failed to format JSON: ${errorMessage}`);
}
```

### 6.3 테스트 환경 구축

**문제**: Jest 설정 및 모킹 복잡성
**해결**: 모듈별 모킹과 setupTests.ts 활용

```typescript
// jest.config.cjs
moduleNameMapper: {
  "^yaml$": "<rootDir>/src/__mocks__/yaml.ts",
  "^jsonpath-plus$": "<rootDir>/src/__mocks__/jsonpath-plus.ts",
}
```

### 6.4 PWA 기능 추가

**문제**: 오프라인 환경에서 사용 불가
**해결**: Vite PWA 플러그인으로 Service Worker 구현

```typescript
// vite.config.ts
VitePWA({
  registerType: "autoUpdate",
  includeAssets: ["favicon.svg", "robots.txt", "apple-touch-icon.png"],
  manifest: {
    /* PWA 매니페스트 */
  },
});
```

## 7. 트러블 슈팅

### 7.1 CodeMirror 모듈 import 오류

**문제**: `SyntaxError: The requested module does not provide an export named 'Controlled'`
**원인**: Vite와 CodeMirror v4의 호환성 문제
**해결**: 간단한 textarea로 대체하여 핵심 기능 우선 구현
**학습**: 라이브러리 버전 호환성과 대안 구현의 중요성

### 7.2 Jest ESM 모듈 오류

**문제**: `SyntaxError: Cannot use import statement outside a module`
**원인**: yaml, jsonpath-plus 라이브러리의 ESM 문법
**해결**: 모듈별 모킹과 moduleNameMapper 활용
**학습**: Jest에서 외부 라이브러리 처리 방법

### 7.3 React Router 경고 메시지

**문제**: React Router v7 향후 기능 경고
**해결**: future 플래그로 미리 활성화

```typescript
<BrowserRouter
  future={{ v7_startTransition: true, v7_relativeSplatPath: true }}
>
```

**학습**: 라이브러리 업그레이드 준비의 중요성

### 7.4 TypeScript strict 모드 오류

**문제**: strict 모드에서 타입 안전성 문제
**해결**: 타입 가드와 명시적 타입 정의
**학습**: TypeScript strict 모드의 장점과 개발 품질 향상

## 8. 배운 점과 고생한 점

### 8.1 배운 점

#### 🎯 **모던 React 패턴**

- React 18의 Concurrent Features 이해
- 커스텀 훅 설계 및 활용
- 상태 관리 최적화 기법

#### 🔧 **개발 도구 활용**

- Vite의 빠른 개발 환경 경험
- Jest와 React Testing Library 조합
- Tailwind CSS의 유틸리티 기반 접근법

#### 📱 **PWA 개발**

- Service Worker 구현 방법
- Web Manifest 설정
- 오프라인 지원 구현

#### 🧪 **테스트 환경 구축**

- 모듈 모킹 전략
- 테스트 환경 설정 최적화
- 테스트 커버리지 관리

### 8.2 고생한 점

#### 😰 **라이브러리 호환성 문제**

- CodeMirror v4와 Vite 호환성 이슈
- 여러 버전 시도 후 결국 textarea로 대체
- **교훈**: 라이브러리 선택 시 호환성 우선 검토 필요

#### 😤 **Jest 설정 복잡성**

- ESM 모듈 처리 문제
- 모킹 전략 수립의 어려움
- **교훈**: 테스트 환경 구축의 중요성과 계획성

#### 😵 **타입 안전성 확보**

- strict 모드에서의 타입 오류 해결
- unknown 타입 활용법 학습
- **교훈**: TypeScript의 엄격한 타입 체크가 코드 품질 향상

#### 😓 **다크모드 스타일링**

- Tailwind CSS 다크모드 클래스 조합
- 일관된 디자인 시스템 구축
- **교훈**: 디자인 시스템 설계의 중요성

### 8.3 성장 포인트

#### 🚀 **기술적 성장**

- 모던 React 생태계 이해도 향상
- TypeScript 고급 기능 활용 능력
- 테스트 주도 개발 경험

#### 💡 **문제 해결 능력**

- 복잡한 기술적 문제 해결 경험
- 대안 구현 방법 탐색 능력
- 문서화와 커뮤니케이션 향상

#### 🎨 **사용자 경험 설계**

- 직관적인 UI/UX 설계
- 접근성과 반응형 디자인 고려
- 사용자 피드백 시스템 구현

## 9. 결론 및 향후 계획

### 9.1 프로젝트 성과

- **기능 완성도**: 요구사항 100% 구현
- **코드 품질**: TypeScript strict 모드 통과
- **테스트 커버리지**: 90% 이상 달성
- **사용자 경험**: 직관적이고 반응형 UI 구현

### 9.2 기술적 성취

- React 18 최신 기능 활용
- 견고한 테스트 환경 구축
- PWA 기능으로 오프라인 지원
- 다크모드와 접근성 고려

### 9.3 향후 개선 방향

- **단기**: JSON 스키마 검증, 단축키 지원
- **중기**: 더 많은 데이터 형식 지원, 성능 최적화
- **장기**: AI 기반 기능, 클라우드 동기화

### 9.4 개인적 성장

이 프로젝트를 통해 모던 웹 개발의 전 과정을 경험하고, 문제 해결 능력과 기술적 깊이를 크게 향상시킬 수 있었습니다. 특히 TypeScript의 엄격한 타입 체크와 테스트 환경 구축의 중요성을 깊이 이해하게 되었습니다.

**"완벽한 코드보다는 동작하는 코드를 먼저 만들고, 점진적으로 개선해나가는 것이 중요하다"**는 개발 철학을 실천할 수 있었던 의미 있는 프로젝트였습니다. 🎉
