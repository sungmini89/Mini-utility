# Lorem Ipsum Generator 개발기 - 기술블로그

## 🏗️ **1. 프로젝트 구조 분석**

### **아키텍처 패턴**

- **컴포넌트 기반**: React 함수형 컴포넌트와 훅 패턴
- **관심사 분리**: UI, 비즈니스 로직, 유틸리티 함수 분리
- **폴더 구조**: 기능별 모듈화된 디렉토리 구성

### **핵심 디렉토리 구조**

```
src/
├── components/LoremGenerator/     # 메인 기능 컴포넌트
│   ├── index.tsx                 # UI 및 상태 관리
│   ├── types.ts                  # TypeScript 타입 정의
│   └── utils.ts                  # 텍스트 생성 로직
├── hooks/                        # 커스텀 훅 모음
│   ├── useLocalStorage.ts        # 로컬 스토리지 관리
│   ├── useClipboard.ts           # 클립보드 복사
│   └── useDarkMode.ts            # 다크모드 상태
└── utils/                        # 공통 유틸리티
    └── common.ts                 # 범용 함수들
```

### **설정 파일 구조**

```
├── vite.config.ts                # Vite + PWA 설정
├── tailwind.config.cjs           # Tailwind CSS + 다크모드
├── jest.config.cjs               # Jest + TypeScript 설정
└── tsconfig.json                 # TypeScript 컴파일러 옵션
```

## 🔄 **2. 상태 관리 흐름 추적**

### **전역 상태 흐름**

```
App Component
├── useDarkMode (다크모드 전역 상태)
└── LoremGeneratorPage
    └── LoremGenerator Component
        ├── useLocalStorage (설정 옵션)
        ├── useLocalStorage (히스토리)
        ├── useState (출력 텍스트)
        ├── useState (로딩 상태)
        └── useClipboard (복사 상태)
```

### **상태 동기화 메커니즘**

- **localStorage 동기화**: useLocalStorage 훅이 상태 변경 시 자동 저장
- **실시간 미리보기**: options 상태 변경 시 useEffect로 output 자동 업데이트
- **히스토리 관리**: 새 텍스트 생성 시 자동으로 히스토리 배열 업데이트

### **상태 업데이트 최적화**

```typescript
// 배치 업데이트로 성능 향상
const updateNumberOption = (key: keyof LoremOptions, value: number) => {
  if (value < 1) value = 1;
  if (value > 100) value = 100;

  setOptions((prev) => ({ ...prev, [key]: value }));
};
```

## ⚙️ **3. 중요 유틸 함수 하나씩 이해**

### **generateLorem 함수 (utils.ts)**

```typescript
export function generateLorem(options: LoremOptions): string {
  // 1. 언어별 어휘 선택
  const vocab = language === "eng" ? ENGLISH_VOCAB : KOREAN_VOCAB;

  // 2. 문단별 문장 생성
  for (let p = 0; p < paragraphs; p++) {
    for (let s = 0; s < sentences; s++) {
      // 3. 단어 배열 생성 및 문장 구성
      const wordsList = generateWords(vocab, words);
      let sentence = wordsList.join(" ");

      // 4. 커스텀 시작 텍스트 처리
      if (p === 0 && s === 0 && customStart.trim().length > 0) {
        sentence = customStart.trim() + " " + sentence;
      }

      // 5. 언어별 문장 마무리
      if (language === "eng") {
        sentence = capitaliseFirst(sentence) + ".";
      } else {
        sentence += ".";
      }
    }
  }

  // 6. 최종 형식 변환 (HTML/리스트/일반)
  return formatOutput(sentencesArray, options);
}
```

**핵심 로직**:

- **어휘 순환**: `generateWords` 함수로 어휘 배열을 순환하며 단어 생성
- **커스텀 시작**: 첫 번째 문장에만 사용자 정의 시작 텍스트 추가
- **언어별 처리**: 영어는 첫 글자 대문자화, 한국어는 그대로 유지

### **generateWords 함수 (common.ts)**

```typescript
export function generateWords(vocab: string[], count: number): string[] {
  const result: string[] = [];
  let i = 0;

  // 어휘 배열을 순환하면서 요청된 단어 수만큼 생성
  while (result.length < count) {
    result.push(vocab[i % vocab.length]);
    i++;
  }

  return result;
}
```

**핵심 로직**:

- **모듈로 연산**: `i % vocab.length`로 어휘 배열 범위를 벗어나지 않음
- **순환 패턴**: 어휘가 부족해도 자연스럽게 반복하여 요청된 단어 수 충족

### **useLocalStorage 훅**

```typescript
function useLocalStorage<T>(key: string, defaultValue: T) {
  const [value, setValue] = useState<T>(() => {
    // SSR 환경에서는 기본값 반환
    if (typeof window === "undefined") return defaultValue;

    try {
      const stored = window.localStorage.getItem(key);
      return stored ? (JSON.parse(stored) as T) : defaultValue;
    } catch (error) {
      console.warn("useLocalStorage: unable to parse stored value", error);
      return defaultValue;
    }
  });

  // 값이 변경될 때마다 localStorage에 저장
  useEffect(() => {
    try {
      window.localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.warn("useLocalStorage: unable to set value", error);
    }
  }, [key, value]);

  return [value, setValue] as [T, React.Dispatch<React.SetStateAction<T>>];
}
```

**핵심 로직**:

- **SSR 안전성**: `typeof window === "undefined"` 체크로 서버사이드 렌더링 지원
- **에러 복구**: JSON 파싱 실패 시 기본값 반환으로 앱 크래시 방지
- **자동 동기화**: 상태 변경 시 자동으로 localStorage에 저장

## 🎯 **4. 메인 컴포넌트 흐름 추적**

### **컴포넌트 생명주기**

1. **마운트**: localStorage에서 설정 및 히스토리 복원
2. **초기 렌더링**: 기본 옵션으로 첫 텍스트 생성
3. **사용자 상호작용**: 옵션 변경, 생성, 복사 등
4. **상태 업데이트**: 실시간 미리보기 및 히스토리 관리
5. **언마운트**: 이벤트 리스너 정리

### **사용자 액션 플로우**

```
사용자 입력 → 상태 업데이트 → useEffect 트리거 → 텍스트 재생성 → UI 업데이트
     ↓
옵션 변경 → 실시간 미리보기
     ↓
Generate 클릭 → 새 텍스트 생성 → 히스토리 추가 → 토스트 알림
     ↓
Copy 클릭 → 클립보드 복사 → 성공/실패 토스트
```

### **키보드 이벤트 처리**

```typescript
useEffect(() => {
  function handleKeyDown(e: KeyboardEvent) {
    const isCtrlOrCmd = e.ctrlKey || e.metaKey;

    // Ctrl/Cmd + Shift + C: 복사
    if (isCtrlOrCmd && e.shiftKey && e.key.toLowerCase() === "c") {
      e.preventDefault();
      handleCopy();
    }

    // Alt + G: 새 텍스트 생성
    if (
      e.altKey &&
      !e.shiftKey &&
      !e.ctrlKey &&
      !e.metaKey &&
      e.key.toLowerCase() === "g"
    ) {
      e.preventDefault();
      handleGenerate();
    }
  }

  window.addEventListener("keydown", handleKeyDown);
  return () => window.removeEventListener("keydown", handleKeyDown);
});
```

**핵심 로직**:

- **키 조합 검증**: 정확한 키 조합만 인식하도록 상세한 조건 검사
- **이벤트 방지**: `preventDefault()`로 브라우저 기본 동작 차단
- **메모리 누수 방지**: 컴포넌트 언마운트 시 이벤트 리스너 정리

## ⚡ **5. 렌더링 최적화 포인트**

### **React.memo 최적화**

- **컴포넌트 메모이제이션**: 불필요한 리렌더링 방지
- **의존성 배열 최적화**: useEffect의 의존성 배열을 최소화
- **콜백 함수 메모이제이션**: useCallback으로 함수 재생성 방지

### **조건부 렌더링 최적화**

```typescript
// 불필요한 DOM 요소 생성 방지
{
  options.includeHtml && (
    <>
      <label htmlFor="tag">Tag</label>
      <select value={options.htmlTag} onChange={handleTagChange}>
        {/* 옵션들 */}
      </select>
    </>
  );
}
```

### **상태 업데이트 최적화**

```typescript
// 함수형 업데이트로 최신 상태 보장
const toggleOption = (key: keyof LoremOptions) => {
  setOptions((prev) => ({ ...prev, [key]: !(prev as any)[key] }));
};
```

### **메모리 사용량 최적화**

```typescript
// 히스토리 배열 크기 제한
setHistory([newEntry, ...history].slice(0, 10));
```

## 🔧 **6. 내가 개선한 부분**

### **JSDoc 문서화 개선**

- **한글 JSDoc**: 한국어 개발자를 위한 친화적 문서화
- **상세한 매개변수 설명**: 각 함수의 입력값과 반환값 명확화
- **실용적인 예시**: 실제 사용 가능한 코드 예시 추가
- **주의사항 안내**: 사용 시 주의해야 할 점들을 명시

### **코드 품질 향상**

- **일관된 코딩 스타일**: Prettier를 통한 코드 포맷팅
- **타입 안전성**: TypeScript 인터페이스 상세 정의
- **에러 처리**: try-catch 블록으로 안전한 에러 핸들링
- **접근성 개선**: ARIA 라벨 및 스크린 리더 지원

### **테스트 환경 구축**

- **Jest 설정**: TypeScript + React + JSX 지원
- **브라우저 API 모킹**: localStorage, clipboard, matchMedia 모킹
- **테스트 커버리지**: 주요 기능에 대한 단위 테스트 작성

## 🚨 **7. 트러블 슈팅**

### **Jest 설정 문제**

**문제**: JSX 문법 파싱 실패, ES 모듈 호환성 문제
**원인**: Jest가 TypeScript와 React JSX를 제대로 처리하지 못함
**해결**:

1. `jest.config.cjs` 파일 생성 (CommonJS 형식)
2. `jest-environment-jsdom` 의존성 추가
3. `setupTests.ts`로 테스트 환경 설정

### **ES 모듈 충돌**

**문제**: `"type": "module"`과 Jest 설정 파일 충돌
**원인**: package.json에서 ES 모듈 설정, Jest는 CommonJS 필요
**해결**: Jest 설정 파일을 `.cjs` 확장자로 변경

### **브라우저 API 모킹**

**문제**: 테스트 환경에서 localStorage, clipboard API 접근 불가
**원인**: Node.js 환경에서는 브라우저 API가 존재하지 않음
**해결**: `setupTests.ts`에서 모든 브라우저 API를 Jest 모킹

```typescript
// setupTests.ts
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
global.localStorage = localStorageMock;

Object.assign(navigator, {
  clipboard: {
    writeText: jest.fn(),
  },
});
```

### **PWA 설정 문제**

**문제**: Service Worker 생성 실패
**원인**: Vite PWA 플러그인 설정 누락
**해결**: `vite.config.ts`에 PWA 매니페스트 및 아이콘 설정 추가

## 📚 **8. 배운 점과 고생한 점**

### **배운 점**

1. **Jest 설정의 복잡성**: TypeScript + React + ES 모듈 환경에서의 Jest 설정 방법
2. **브라우저 API 모킹**: 테스트 환경에서 실제 브라우저 API를 안전하게 모킹하는 방법
3. **PWA 설정**: Vite + PWA 플러그인을 통한 Progressive Web App 구현
4. **다크모드 구현**: Tailwind CSS와 React 훅을 활용한 테마 시스템 구축
5. **상태 관리 최적화**: React 훅을 활용한 효율적인 상태 관리 패턴

### **고생한 점**

1. **Jest 설정 디버깅**: 여러 의존성과 설정 파일 간의 충돌 해결
2. **ES 모듈 호환성**: package.json의 "type": "module"과 Jest 설정 간의 충돌
3. **브라우저 API 모킹**: localStorage, clipboard, matchMedia 등 다양한 API 모킹
4. **테스트 환경 구축**: React Testing Library와 Jest DOM 설정
5. **PWA 설정**: Service Worker 생성 및 매니페스트 설정

### **성장 포인트**

- **테스트 환경 구축**: 프로덕션 레벨의 테스트 환경 구성 능력 향상
- **문서화**: 개발자 친화적인 JSDoc 작성 능력 개선
- **문제 해결**: 복잡한 설정 문제를 체계적으로 디버깅하는 능력 향상
- **코드 품질**: 일관된 코딩 스타일과 타입 안전성 확보
- **성능 최적화**: React 렌더링 최적화 및 메모리 관리 능력 향상

### **다음 프로젝트에서 적용할 점**

1. **설정 파일 표준화**: Jest, TypeScript, ESLint 설정 템플릿화
2. **테스트 우선 개발**: TDD 방식으로 테스트 코드 먼저 작성
3. **문서화 자동화**: JSDoc 생성 및 유지보수 자동화 도구 도입
4. **성능 모니터링**: Lighthouse CI를 통한 지속적인 성능 측정
5. **접근성 검증**: axe-core를 통한 자동화된 접근성 테스트
