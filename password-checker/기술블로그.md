# React + TypeScript로 만든 비밀번호 강도 검사기 개발기

## 1. 프로젝트 구조 분석

### 1.1 전체 아키텍처

```
password-checker/
├── src/
│   ├── components/
│   │   ├── PasswordChecker/
│   │   │   ├── index.tsx          # 메인 컴포넌트
│   │   │   ├── types.ts           # 타입 정의
│   │   │   ├── utils.ts           # 비밀번호 평가 로직
│   │   │   └── index.test.tsx     # 테스트 파일
│   │   └── ErrorBoundary.tsx      # 에러 경계
│   ├── hooks/
│   │   ├── useDarkMode.ts         # 다크모드 훅
│   │   ├── useLocalStorage.ts     # 로컬스토리지 훅
│   │   └── useClipboard.ts        # 클립보드 훅
│   ├── pages/
│   │   └── PasswordCheckerPage.tsx # 페이지 컴포넌트
│   ├── utils/
│   │   └── common.ts              # 공통 유틸리티
│   ├── App.tsx                    # 앱 루트 컴포넌트
│   ├── main.tsx                   # 진입점
│   └── setupTests.ts              # 테스트 설정
├── public/                        # 정적 파일
├── dist/                          # 빌드 결과물
└── 설정 파일들 (vite.config.ts, tsconfig.json 등)
```

### 1.2 핵심 설계 원칙

- **단일 책임 원칙**: 각 컴포넌트와 훅이 명확한 하나의 역할만 담당
- **관심사 분리**: UI 로직, 비즈니스 로직, 데이터 관리 로직 분리
- **재사용성**: 커스텀 훅을 통한 로직 재사용
- **타입 안전성**: TypeScript를 통한 컴파일 타임 오류 방지

## 2. 상태 관리 흐름 추적

### 2.1 상태 구조

```typescript
// PasswordChecker 컴포넌트 상태
const [password, setPassword] = useState(""); // 입력 비밀번호
const [result, setResult] = useState<EvaluationResult | null>(null); // 평가 결과
const [showPassword, setShowPassword] = useState(false); // 비밀번호 표시 여부

// 커스텀 훅 상태
const { copyToClipboard, copied } = useClipboard(); // 클립보드 상태
const [history, setHistory] = useLocalStorage<string[]>; // 히스토리 상태
```

### 2.2 상태 흐름도

```
사용자 입력 → password 상태 변경 → useEffect 트리거 → evaluatePassword 실행 → result 상태 업데이트 → UI 리렌더링
                ↓
            디바운싱 (100ms) → 성능 최적화
                ↓
            zxcvbn 분석 → 강도 점수, 해킹 시간, 제안사항 계산
                ↓
            한국어 번역 → 사용자 친화적 메시지 변환
```

### 2.3 상태 동기화 전략

- **로컬스토리지**: `useLocalStorage` 훅으로 히스토리와 다크모드 설정 영구 저장
- **세션 스토리지**: 임시 입력 데이터는 페이지 새로고침 시 자동 삭제
- **상태 정규화**: 복잡한 상태를 단순한 형태로 정규화하여 관리

## 3. 중요 유틸 함수 하나씩 이해

### 3.1 `evaluatePassword` 함수

```typescript
export function evaluatePassword(password: string): EvaluationResult {
  // 1. 빈 비밀번호 처리
  if (!password || password.length === 0) {
    return {
      /* 기본값 */
    };
  }

  // 2. zxcvbn 라이브러리 분석
  const analysis = zxcvbn(password);
  const zScore = analysis.score; // 0-4 점수
  const normalised = Math.min(100, Math.max(0, Math.round((zScore / 4) * 100)));

  // 3. 해킹 시간 한국어 번역
  let crackTime = "알 수 없음";
  if (analysis.crack_times_display) {
    const timeValue =
      analysis.crack_times_display.offline_slow_hashing_1e4_per_second;
    crackTime = translateCrackTime(String(timeValue));
  }

  // 4. 추가 보안 요구사항 검사
  const hasLower = /[a-z]/.test(password);
  const hasUpper = /[A-Z]/.test(password);
  const hasNumber = /\d/.test(password);
  const hasSpecial = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);

  return {
    /* 평가 결과 */
  };
}
```

**핵심 포인트:**

- zxcvbn의 0-4 점수를 0-100%로 정규화
- 해킹 시간을 한국어로 번역하여 사용자 친화적 표시
- 정규표현식을 활용한 추가 보안 요구사항 검증

### 3.2 `translateCrackTime` 함수

```typescript
function translateCrackTime(timeString: string): string {
  const timeMap: Record<string, string> = {
    instant: "즉시",
    seconds: "초",
    minutes: "분",
    hours: "시간",
    days: "일",
    months: "개월",
    years: "년",
    centuries: "세기",
  };

  // 숫자와 단위 분리 후 번역
  const match = timeString.match(/^(\d+(?:\.\d+)?)\s*(.+)$/);
  if (match) {
    const [, number, unit] = match;
    const translatedUnit = timeMap[unit] || unit;
    return `${number} ${translatedUnit}`;
  }

  return timeMap[timeString] || timeString;
}
```

**핵심 포인트:**

- 정규표현식으로 숫자와 단위 분리
- 매핑 테이블을 통한 체계적 번역
- fallback 처리로 안정성 확보

### 3.3 `useLocalStorage` 훅

```typescript
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}
```

**핵심 포인트:**

- 제네릭을 활용한 타입 안전성
- 함수형 업데이트 지원
- 에러 처리로 안정성 확보
- lazy initialization으로 성능 최적화

## 4. 메인 컴포넌트 흐름 추적

### 4.1 PasswordChecker 컴포넌트 생명주기

```typescript
const PasswordChecker: React.FC = () => {
  // 1. 상태 초기화
  const [password, setPassword] = useState("");
  const [result, setResult] = useState<EvaluationResult | null>(null);
  const [showPassword, setShowPassword] = useState(false);
  const { copyToClipboard, copied } = useClipboard();
  const [history, setHistory] = useLocalStorage<string[]>("passwordHistory", []);

  // 2. 비밀번호 평가 효과
  useEffect(() => {
    const timer = setTimeout(() => {
      if (password) {
        try {
          const evaluation = evaluatePassword(password);
          setResult(evaluation);
        } catch (error) {
          console.error("Password evaluation error:", error);
          setResult(null);
        }
      } else {
        setResult(null);
      }
    }, 100); // 디바운싱

    return () => clearTimeout(timer);
  }, [password]);

  // 3. 키보드 단축키 효과
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.ctrlKey && e.shiftKey) {
        switch (e.key.toLowerCase()) {
          case "c": copyToClipboard(password); break;
          case "s": saveToHistory(); break;
          case "x": clearPassword(); break;
        }
      }
    };

    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [password, result, history]);

  // 4. 렌더링
  return (/* JSX */);
};
```

### 4.2 렌더링 최적화 전략

- **조건부 렌더링**: `result`가 있을 때만 평가 결과 표시
- **메모이제이션**: `useCallback`으로 함수 재생성 방지
- **디바운싱**: 연속 입력 시 불필요한 평가 방지
- **에러 경계**: 컴포넌트 오류 시 graceful degradation

## 5. 렌더링 최적화 포인트

### 5.1 성능 최적화 기법

```typescript
// 1. 디바운싱으로 불필요한 평가 방지
useEffect(() => {
  const timer = setTimeout(() => {
    // 평가 로직
  }, 100);
  return () => clearTimeout(timer);
}, [password]);

// 2. useCallback으로 함수 메모이제이션
const saveToHistory = useCallback(() => {
  // 저장 로직
}, [password, result, history, setHistory]);

// 3. 조건부 렌더링으로 불필요한 DOM 생성 방지
{
  result && <div className="evaluation-result">{/* 평가 결과 UI */}</div>;
}

// 4. CSS 클래스 동적 계산 최적화
const getStrengthColor = (score: number) => {
  if (score < 25) return "text-red-500";
  if (score < 50) return "text-orange-500";
  if (score < 75) return "text-yellow-500";
  return "text-green-500";
};
```

### 5.2 번들 최적화

```typescript
// vite.config.ts
export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ["react", "react-dom"],
          router: ["react-router-dom"],
        },
      },
    },
  },
});
```

## 6. 내가 개선한 부분

### 6.1 한국어 번역 시스템

**문제**: zxcvbn 라이브러리가 영어 메시지만 제공
**해결**: 체계적인 번역 시스템 구축

```typescript
// 해킹 시간 번역
function translateCrackTime(timeString: string): string {
  const timeMap: Record<string, string> = {
    centuries: "세기",
    years: "년",
    months: "개월",
    // ...
  };
  // 번역 로직
}

// 제안 메시지 번역
function translateSuggestions(suggestions: string[]): string[] {
  const suggestionMap: Record<string, string> = {
    "Add another word or two. Uncommon words are better.":
      "다른 단어를 하나 또는 두 개 추가하세요. 흔하지 않은 단어가 더 좋습니다.",
    // ...
  };
  return suggestions.map(
    (suggestion) => suggestionMap[suggestion] || suggestion
  );
}
```

### 6.2 다크모드 UX 개선

**문제**: 다크모드에서 입력창이 잘 보이지 않음
**해결**: 명시적인 다크모드 스타일 적용

```css
/* 다크모드 최적화된 입력창 스타일 */
className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600
          rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent
          dark:bg-gray-700 dark:text-white text-gray-900 dark:text-white
          placeholder-gray-500 dark:placeholder-gray-400"
```

### 6.3 타입 안전성 강화

**문제**: TypeScript 오류와 암시적 any 타입
**해결**: 엄격한 타입 정의와 제네릭 활용

```typescript
// 명시적 타입 정의
interface EvaluationResult {
  score: number;
  zxcvbnScore: number;
  crackTime: string;
  feedback: {
    warning: string;
    suggestions: string[];
  };
  hasMinLength: boolean;
  hasUpperLower: boolean;
  hasNumber: boolean;
  hasSpecial: boolean;
  length: number;
}

// 제네릭 훅
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void];
```

## 7. 트러블 슈팅

### 7.1 React Router 중첩 오류

**문제**: `You cannot render a <Router> inside another <Router>`
**원인**: `App.tsx`와 `main.tsx`에서 중복으로 `BrowserRouter` 사용
**해결**: `App.tsx`에서 `BrowserRouter` 제거, `main.tsx`에서만 사용

### 7.2 PWA 아이콘 로딩 오류

**문제**: `Error while trying to use the following icon from the Manifest`
**원인**: `vite-plugin-pwa` 설정 복잡성과 MIME 타입 문제
**해결**: 플러그인 제거하고 `index.html`에서 직접 manifest 링크

### 7.3 React DOM 오류

**문제**: `NotFoundError: Failed to execute 'insertBefore' on 'Node'`
**원인**: 복잡한 상태 관리와 디버그 컴포넌트로 인한 DOM 조작 충돌
**해결**: 컴포넌트 구조 단순화 및 불필요한 디버그 코드 제거

### 7.4 TypeScript 오류

**문제**: `Property 'value' does not exist on type '[string[], (value: string[] | ((val: string[]) => string[])) => void]'`
**원인**: 훅 반환 타입 변경으로 인한 구조 분해 할당 오류
**해결**: 배열 구조 분해 할당으로 통일

### 7.5 JSON 주석 오류

**문제**: `Comments are not permitted in JSON`
**원인**: `package.json`에 JSDoc 주석 추가 시도
**해결**: JSON 파일은 주석을 지원하지 않으므로 주석 제거

## 8. 배운 점과 고생한 점

### 8.1 기술적 배움

- **zxcvbn 라이브러리**: 실제 비밀번호 강도 측정 알고리즘 이해
- **TypeScript 제네릭**: 타입 안전한 커스텀 훅 설계
- **React Hooks**: 상태 관리와 사이드 이펙트 최적화
- **Vite 설정**: 번들 최적화와 개발 환경 구성
- **Jest 테스팅**: 컴포넌트 테스트와 모킹 전략

### 8.2 아키텍처 설계 배움

- **관심사 분리**: UI, 비즈니스 로직, 데이터 관리 분리
- **재사용성**: 커스텀 훅을 통한 로직 재사용
- **타입 안전성**: 컴파일 타임 오류 방지의 중요성
- **성능 최적화**: 디바운싱과 메모이제이션 활용

### 8.3 고생한 점

- **PWA 설정**: 복잡한 설정과 브라우저 호환성 문제
- **다국어 지원**: 라이브러리 메시지 번역의 체계적 접근
- **타입 오류**: 복잡한 타입 정의와 오류 해결
- **테스트 환경**: Jest 설정과 모킹 전략 구축

### 8.4 성장 포인트

- **문제 해결 능력**: 체계적인 디버깅과 오류 해결
- **코드 품질**: 일관된 코딩 스타일과 문서화
- **사용자 경험**: 접근성과 반응형 디자인 고려
- **프로젝트 관리**: 요구사항 분석부터 배포까지 전체 과정 경험

### 8.5 향후 개선 방향

- **성능 최적화**: React.memo와 useMemo 활용
- **테스트 커버리지**: 더 많은 엣지 케이스 테스트
- **접근성**: ARIA 라벨과 키보드 네비게이션 개선
- **PWA 기능**: 오프라인 동작과 푸시 알림 구현

이 프로젝트를 통해 React 생태계의 다양한 기술을 실제로 적용해보며, 프론트엔드 개발의 전체 과정을 경험할 수 있었습니다. 특히 타입 안전성과 사용자 경험의 중요성을 깊이 이해하게 되었고, 앞으로 더 나은 개발자가 되기 위한 좋은 학습 경험이었습니다.
