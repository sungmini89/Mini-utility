# Case Converter 프로젝트 기술블로그

## 🚀 **프로젝트 개요**

**Case Converter**는 React 18 + TypeScript + Vite로 구축된 텍스트 케이스 변환 웹 애플리케이션입니다. 이 프로젝트를 통해 현대적인 React 애플리케이션 개발의 전체 과정을 경험하고, 실제 프로덕션 환경에서 발생할 수 있는 다양한 문제들을 해결하는 능력을 키울 수 있었습니다.

---

## 1. 프로젝트 구조 분석

### 1.1 아키텍처 패턴

#### **컴포넌트 기반 설계**

```
src/
├── components/     # UI 컴포넌트 (단일 책임 원칙)
├── hooks/         # 비즈니스 로직 (관심사 분리)
├── pages/         # 라우트별 페이지 (코드 분할)
├── utils/         # 공통 유틸리티 (재사용성)
```

**장점**:

- **관심사 분리**: 각 폴더가 명확한 역할을 가짐
- **확장성**: 새로운 기능 추가 시 적절한 위치에 배치 가능
- **테스트 용이성**: 각 모듈을 독립적으로 테스트 가능
- **유지보수성**: 코드 구조가 명확하여 수정이 용이

#### **모듈화 전략**

- **CaseConverter 컴포넌트**: 메인 UI와 상태 관리
- **커스텀 훅들**: 비즈니스 로직을 React 훅으로 분리
- **유틸리티 함수들**: 순수 함수들을 별도 모듈로 분리
- **타입 정의**: TypeScript 인터페이스와 타입 별도 관리

### 1.2 폴더 구조의 설계 철학

#### **계층적 구조**

```
CaseConverter/
├── index.tsx      # 메인 컴포넌트 (UI 로직)
├── types.ts       # 타입 정의 (타입 안전성)
├── utils.ts       # 변환 함수들 (비즈니스 로직)
└── index.test.tsx # 테스트 파일 (품질 보증)
```

**설계 원칙**:

- **단일 책임**: 각 파일이 하나의 명확한 역할만 담당
- **의존성 방향**: 상위 레벨에서 하위 레벨로 의존성 흐름
- **테스트 친화적**: 각 모듈을 독립적으로 테스트 가능

---

## 2. 상태 관리 흐름 추적

### 2.1 상태 흐름도

```
사용자 입력 → CaseConverter 컴포넌트 → useLocalStorage 훅 → localStorage
                ↓
            변환 로직 → utils.ts → 출력 텍스트
                ↓
            히스토리 업데이트 → useLocalStorage 훅 → localStorage
```

#### **상태 관리 특징**

**로컬 상태 (useState)**

```typescript
const [option, setOption] = useState<CaseOption>("UPPERCASE");
const [output, setOutput] = useState<string>(() => convert(input, "UPPERCASE"));
const [toast, setToast] = useState<{
  message: string;
  type: "success" | "error";
} | null>(null);
```

**영구 상태 (useLocalStorage)**

```typescript
const [input, setInput] = useLocalStorage<string>("caseConverter:input", "");
const [history, setHistory] = useLocalStorage<HistoryItem[]>(
  "caseConverter:history",
  []
);
```

**파생 상태 (useEffect)**

```typescript
useEffect(() => {
  setOutput(convert(input, option));
}, [input, option]);
```

### 2.2 상태 동기화 메커니즘

#### **자동 동기화**

- 입력 텍스트나 변환 옵션이 변경될 때마다 출력 자동 계산
- 히스토리 변경 시 localStorage에 자동 저장
- 테마 변경 시 DOM 클래스 자동 업데이트

#### **상태 정규화**

```typescript
// 히스토리 항목 구조
interface HistoryItem {
  option: CaseOption; // 변환 옵션
  input: string; // 입력 텍스트
  output: string; // 출력 텍스트
  date: number; // 타임스탬프
}
```

---

## 3. 중요 유틸 함수 하나씩 이해

### 3.1 케이스 변환 함수들

#### **Title Case 변환**

```typescript
function toTitleCase(text: string): string {
  return text.toLowerCase().replace(/\b\w/g, (char) => char.toUpperCase());
}
```

**정규식 분석**:

- `/\b\w/g`: 단어 경계(`\b`)에서 시작하는 문자(`\w`) 매칭
- `\b`: 단어 경계 (공백, 구두점, 문자열 시작/끝)
- `\w`: 영숫자 문자 (a-z, A-Z, 0-9, \_)

**사용 예시**:

```typescript
toTitleCase("hello world"); // "Hello World"
toTitleCase("HELLO WORLD"); // "Hello World"
toTitleCase("hello-world"); // "Hello-world"
```

#### **camelCase 변환**

```typescript
function toCamelCase(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^a-zA-Z0-9]+(.)/g, (_, group1: string) => group1.toUpperCase());
}
```

**정규식 분석**:

- `/[^a-zA-Z0-9]+(.)/g`: 영숫자가 아닌 문자(`[^a-zA-Z0-9]+`) 다음의 문자(`(.)`) 캡처
- `[^a-zA-Z0-9]+`: 영숫자가 아닌 문자가 1개 이상
- `(.)`: 캡처 그룹으로, 대문자로 변환할 문자

**사용 예시**:

```typescript
toCamelCase("hello world"); // "helloWorld"
toCamelCase("hello-world"); // "helloWorld"
toCamelCase("hello_world"); // "helloWorld"
```

#### **snake_case 변환**

```typescript
function toSnakeCase(text: string): string {
  return text
    .trim()
    .replace(/[^a-zA-Z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "")
    .toLowerCase();
}
```

**정규식 분석**:

- `/[^a-zA-Z0-9]+/g`: 영숫자가 아닌 문자를 언더스코어로 변환
- `/^_+|_+$/g`: 시작(`^_+`)과 끝(`_+$`)의 연속된 언더스코어 제거

**사용 예시**:

```typescript
toSnakeCase("hello world"); // "hello_world"
toSnakeCase("Hello World"); // "hello_world"
toSnakeCase("hello-world"); // "hello_world"
```

### 3.2 공통 유틸리티 함수

#### **텍스트 자르기 함수**

```typescript
export function truncate(text: string, length: number = 50): string {
  if (text.length <= length) return text;
  return `${text.slice(0, length)}…`;
}
```

**특징**:

- 기본 길이 50자로 설정
- 유니코드 이모지(`…`) 사용으로 시각적 일관성
- 메모리 효율적인 문자열 처리

---

## 4. 메인 컴포넌트 흐름 추적

### 4.1 렌더링 생명주기

#### **초기화 단계**

1. **컴포넌트 마운트**: React 컴포넌트 트리 생성
2. **훅 초기화**: `useLocalStorage`, `useClipboard` 등 커스텀 훅 실행
3. **상태 복원**: localStorage에서 저장된 입력 텍스트와 히스토리 로드
4. **초기 출력 계산**: `convert(input, 'UPPERCASE')` 실행

#### **상태 동기화 단계**

```typescript
useEffect(() => {
  setOutput(convert(input, option));
}, [input, option]);
```

**동작 과정**:

1. `input` 또는 `option` 상태 변경 감지
2. `convert` 함수 호출하여 새로운 출력 계산
3. `setOutput`으로 출력 상태 업데이트
4. React의 가상 DOM을 통한 효율적인 렌더링

#### **사용자 상호작용 단계**

1. **텍스트 입력**: `onChange` 이벤트로 `input` 상태 업데이트
2. **옵션 선택**: 버튼 클릭으로 `option` 상태 업데이트
3. **액션 실행**: 복사, 붙여넣기, 초기화 등 사용자 액션 처리
4. **히스토리 업데이트**: 변환 결과를 히스토리에 추가

### 4.2 이벤트 핸들링

#### **키보드 단축키 처리**

```typescript
useEffect(() => {
  function handleKeyDown(e: KeyboardEvent) {
    // Alt + 숫자로 케이스 변환 옵션 선택
    if (e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey) {
      const num = Number(e.key);
      if (num >= 1 && num <= OPTIONS.length) {
        e.preventDefault();
        handleConvert(OPTIONS[num - 1]);
      }
    }

    // Ctrl/Cmd + Shift + C로 복사
    const isCtrlOrCmd = e.ctrlKey || e.metaKey;
    if (isCtrlOrCmd && e.shiftKey && e.key.toLowerCase() === "c") {
      e.preventDefault();
      handleCopy();
    }
  }

  window.addEventListener("keydown", handleKeyDown);
  return () => window.removeEventListener("keydown", handleKeyDown);
}, [input, option, history]);
```

**핵심 포인트**:

- **이벤트 위임**: `window` 레벨에서 키보드 이벤트 처리
- **키 조합 검증**: Alt, Ctrl, Shift, Meta 키의 조합 확인
- **메모리 누수 방지**: 컴포넌트 언마운트 시 이벤트 리스너 제거
- **의존성 배열**: 필요한 상태들을 의존성 배열에 포함

---

## 5. 렌더링 최적화 포인트

### 5.1 메모이제이션 전략

#### **의존성 배열 최적화**

```typescript
// 올바른 의존성 배열 사용
useEffect(() => {
  setOutput(convert(input, option));
}, [input, option]); // input과 option만 의존성으로 설정

// 이벤트 리스너 정리
useEffect(() => {
  const timer = setTimeout(() => setToast(null), 2000);
  return () => clearTimeout(timer);
}, [toast]); // toast 상태만 의존성으로 설정
```

#### **상태 업데이트 배치**

```typescript
function handleConvert(newOption: CaseOption) {
  setOption(newOption);
  const newOutput = convert(input, newOption);
  setOutput(newOutput);

  // 히스토리 업데이트를 한 번에 처리
  const item: HistoryItem = {
    option: newOption,
    input,
    output: newOutput,
    date: Date.now(),
  };
  setHistory([item, ...history].slice(0, 10));
}
```

### 5.2 성능 개선 포인트

#### **히스토리 제한**

```typescript
// 메모리 사용량 제어
setHistory([item, ...history].slice(0, 10)); // 최대 10개만 유지
```

**효과**:

- 메모리 사용량 일정 수준 유지
- 스크롤 성능 향상
- 렌더링 시간 단축

#### **토스트 자동 숨김**

```typescript
useEffect(() => {
  if (!toast) return;
  const timer = setTimeout(() => setToast(null), 2000);
  return () => clearTimeout(timer);
}, [toast]);
```

**효과**:

- 불필요한 렌더링 방지
- 사용자 경험 향상
- 메모리 누수 방지

---

## 6. 내가 개선한 부분

### 6.1 크롬 자동 번역 방지

#### **문제 상황**

- 크롬의 자동 번역으로 인한 텍스트 변환 오류
- 한국어 페이지에서 영어 텍스트가 자동 번역됨
- 케이스 변환 결과의 정확성 저하

#### **해결 방법**

```html
<html lang="ko" translate="no">
  <body translate="no">
    <div translate="no"></div>
  </body>
</html>
```

**적용 범위**:

- HTML 문서 전체
- React 컴포넌트들
- 사용자 입력/출력 영역
- UI 텍스트 요소들

#### **개선 효과**

- 원본 텍스트 보존
- 케이스 변환 정확성 향상
- 사용자 경험 개선

### 6.2 React Router v7 호환성

#### **문제 상황**

```
⚠️ React Router Future Flag Warning: React Router will begin wrapping state updates in `React.startTransition` in v7
```

#### **해결 방법**

```typescript
const router = createBrowserRouter([{ path: "/*", element: <App /> }], {
  future: {
    v7_startTransition: true,
    v7_relativeSplatPath: true,
  },
});
```

**변경 사항**:

- `BrowserRouter` → `createBrowserRouter` + `RouterProvider`
- future flag 설정으로 v7 호환성 준비
- 경고 메시지 완전 제거

#### **개선 효과**

- React Router v7 경고 제거
- 향후 업그레이드 준비
- 더 나은 성능과 안정성

### 6.3 PWA 설정 최적화

#### **문제 상황**

- 불필요한 PNG 아이콘 파일들로 인한 404 오류
- PWA 매니페스트 설정의 복잡성
- 파일 관리의 어려움

#### **해결 방법**

```typescript
// vite.config.ts
VitePWA({
  includeAssets: ["favicon.svg", "robots.txt"],
  manifest: {
    icons: [
      {
        src: "favicon.svg",
        sizes: "any",
        type: "image/svg+xml",
      },
    ],
  },
});
```

**개선 사항**:

- SVG 아이콘을 PWA 아이콘으로 사용
- 불필요한 PNG 파일 제거
- 설정 단순화

#### **개선 효과**

- 404 오류 완전 제거
- PWA 기능 정상 동작
- 유지보수성 향상

---

## 7. 트러블 슈팅

### 7.1 주요 문제들과 해결 과정

#### **1. Favicon 404 오류**

```
GET http://localhost:5173/favicon.svg 404 (Not Found)
```

**원인 분석**:

- `public` 폴더가 존재하지 않음
- favicon.svg 파일이 없음
- HTML에서 favicon 경로 참조

**해결 과정**:

1. `public` 폴더 생성
2. favicon.svg 파일 생성 (케이스 변환기 아이콘)
3. robots.txt 파일 추가
4. vite.config.ts에서 PWA 설정 최적화

#### **2. TypeScript 컴파일 오류**

```
Uncaught SyntaxError: The requested module does not provide an export named 'UNSAFE_future'
```

**원인 분석**:

- React Router v6에서 `UNSAFE_future` export 문제
- 잘못된 future flag 설정 방식

**해결 과정**:

1. `UNSAFE_future` import 제거
2. `createBrowserRouter` 방식으로 변경
3. future flag를 올바른 방식으로 설정
4. `RouterProvider` 사용으로 라우터 구조 개선

#### **3. PWA 관련 오류**

- PWA 아이콘 로드 실패
- 매니페스트 설정 오류
- 불필요한 파일들로 인한 복잡성

**해결 과정**:

1. 불필요한 PNG 아이콘 파일들 제거
2. SVG 아이콘을 PWA 아이콘으로 사용
3. vite.config.ts 설정 단순화
4. PWA 메타데이터 한국어화

### 7.2 해결 방법의 선택 이유

#### **실용적 접근**

- 복잡한 설정보다는 간단하고 효과적인 해결책 선택
- 현재 요구사항에 맞는 최소한의 설정
- 향후 확장 가능성 고려

#### **향후 호환성**

- React Router v7 준비
- PWA 표준 준수
- 최신 웹 기술 활용

#### **사용자 경험**

- 번역으로 인한 기능 오류 방지
- 안정적인 PWA 동작
- 일관된 사용자 인터페이스

---

## 8. 배운 점과 고생한 점

### 8.1 배운 점

#### **React Router v6의 새로운 패턴**

- `createBrowserRouter`와 `RouterProvider`의 활용
- future flag를 통한 버전 호환성 관리
- 라우터 설정의 모던한 접근 방식

#### **PWA 설정의 복잡성**

- 매니페스트 파일의 세부 설정
- 아이콘 파일 관리의 중요성
- 서비스 워커와 오프라인 동작의 이해

#### **크로스 브라우저 호환성**

- 다양한 브라우저의 동작 차이
- 클립보드 API의 브라우저별 지원 현황
- localStorage 권한과 제한사항

#### **TypeScript strict 모드**

- 엄격한 타입 체크의 중요성
- 타입 안전성을 통한 런타임 오류 방지
- 코드 품질과 유지보수성 향상

### 8.2 고생한 점

#### **React Router 경고 해결**

- `UNSAFE_future` export 문제로 인한 반복적인 시도
- 다양한 설정 방법의 실험과 검증
- 문서와 예제 코드의 차이점 이해

#### **PWA 설정 최적화**

- 불필요한 파일들과 설정의 정리 과정
- PWA 표준과 Vite 플러그인의 호환성 확인
- 다양한 설정 옵션의 효과 검증

#### **크롬 번역 방지**

- 모든 HTML 요소에 `translate="no"` 속성 추가의 번거로움
- React 컴포넌트의 모든 레벨에서 속성 적용
- 번역 방지 효과의 검증

#### **한글 JSDoc 작성**

- 기존 영어 주석을 한국어로 변환하는 작업
- 기술 용어의 적절한 한국어 표현
- 일관된 문서 스타일 유지

### 8.3 성장 포인트

#### **문제 해결 능력**

- 다양한 오류와 경고를 체계적으로 해결
- 로그 분석과 디버깅 기술 향상
- 해결책의 우선순위 설정과 실행

#### **문서화 능력**

- README와 JSDoc을 통한 프로젝트 가이드 작성
- 사용자와 개발자를 위한 명확한 설명
- 트러블슈팅 가이드의 체계적 정리

#### **사용자 경험 고려**

- 번역 문제 등 사용자가 겪을 수 있는 문제 사전 방지
- 접근성과 사용성의 균형 조절
- 다양한 사용자 시나리오 고려

#### **코드 품질 향상**

- TypeScript strict 모드와 ESLint 규칙 준수
- 일관된 코딩 스타일과 네이밍 컨벤션
- 테스트 코드 작성과 품질 보증

---

## 9. 결론

Case Converter 프로젝트를 통해 현대적인 React 애플리케이션 개발의 전체 과정을 경험할 수 있었습니다. 단순한 기능 구현을 넘어서 실제 프로덕션 환경에서 발생할 수 있는 다양한 문제들을 해결하고, 사용자 경험을 개선하는 과정에서 많은 것을 배울 수 있었습니다.

### **주요 성과**

- **기술적 역량**: React 18, TypeScript, Vite 등 최신 기술 스택 활용
- **문제 해결 능력**: 다양한 오류와 경고를 체계적으로 해결
- **사용자 중심 사고**: 번역 문제 등 사용자 경험 개선
- **문서화 능력**: README, JSDoc, 트러블슈팅 가이드 작성

### **향후 발전 방향**

- **성능 최적화**: React.memo, useMemo, useCallback 등 메모이제이션 활용
- **테스트 커버리지**: Jest와 React Testing Library를 활용한 포괄적 테스트
- **접근성 향상**: ARIA 속성과 키보드 네비게이션 개선
- **PWA 기능 확장**: 오프라인 동작과 푸시 알림 구현

이 프로젝트는 단순한 텍스트 변환 도구를 넘어서, 현대적인 웹 개발의 모든 측면을 경험할 수 있는 훌륭한 학습 기회였습니다. 앞으로도 지속적인 개선과 새로운 기능 추가를 통해 더 나은 사용자 경험을 제공할 수 있도록 노력하겠습니다.

---

**작성일**: 2024년 8월 30일  
**작성자**: 개발자  
**프로젝트**: Case Converter  
**기술 스택**: React 18 + TypeScript + Vite + Tailwind CSS
