# 🚀 날짜 계산기 프로젝트 기술블로그

## 📋 프로젝트 개요

**프로젝트명**: 날짜 계산기  
**기술 스택**: React 18 + TypeScript + Vite + Tailwind CSS  
**개발 기간**: 4주  
**목적**: 한국 공휴일을 고려한 정확한 날짜 계산 도구 개발

---

## 🏗️ 1. 프로젝트 구조 분석

### 1.1 전체 아키텍처

```
date-calculator/
├── public/                 # 정적 자산
│   ├── icons/             # PWA 아이콘 (SVG)
│   ├── manifest.json      # PWA 매니페스트
│   └── sw-clear.js       # 서비스 워커 정리 스크립트
├── src/
│   ├── components/        # 공통 컴포넌트
│   │   ├── ErrorBoundary.tsx
│   │   └── LoadingSpinner.tsx
│   ├── hooks/            # 커스텀 훅
│   │   ├── useDarkMode.ts
│   │   ├── useLocalStorage.ts
│   │   └── useClipboard.ts
│   ├── pages/            # 페이지 컴포넌트
│   │   ├── HomePage.tsx
│   │   ├── BetweenDatesPage.tsx
│   │   ├── AddSubtractPage.tsx
│   │   └── CountdownPage.tsx
│   ├── utils/            # 유틸리티 함수
│   ├── App.tsx           # 메인 앱 컴포넌트
│   ├── main.tsx          # 진입점
│   └── setupTests.ts     # 테스트 환경 설정
├── vite.config.ts        # Vite 설정
├── jest.config.js        # Jest 설정
└── package.json          # 의존성 관리
```

### 1.2 핵심 설계 원칙

- **컴포넌트 분리**: 각 페이지를 독립적인 컴포넌트로 구성
- **훅 기반 로직**: 비즈니스 로직을 커스텀 훅으로 분리
- **타입 안전성**: TypeScript로 런타임 오류 최소화
- **PWA 우선**: 모바일 사용자 경험 최적화

---

## 🔄 2. 상태 관리 흐름 추적

### 2.1 전역 상태 구조

```typescript
// 다크모드 상태
const [isDarkMode, toggleDarkMode] = useDarkMode();

// 로컬 스토리지 상태
const [savedCountdowns, setSavedCountdowns] = useLocalStorage("countdowns", []);

// 페이지별 로컬 상태
const [startDate, setStartDate] = useState<Date | null>(null);
const [endDate, setEndDate] = useState<Date | null>(null);
```

### 2.2 상태 흐름 다이어그램

```
사용자 입력 → 컴포넌트 상태 → 커스텀 훅 → localStorage → UI 업데이트
    ↓              ↓           ↓           ↓           ↓
날짜 선택    →  useState   →  useLocalStorage → 브라우저 저장 → 화면 반영
```

### 2.3 상태 동기화 전략

- **useEffect**: 컴포넌트 마운트 시 localStorage에서 상태 복원
- **이벤트 리스너**: storage 이벤트로 탭 간 동기화
- **에러 바운더리**: 상태 오류 시 graceful fallback

---

## 🛠️ 3. 중요 유틸 함수 하나씩 이해

### 3.1 날짜 계산 유틸리티

#### `differenceInDays` 함수

```typescript
const differenceInDays = (startDate: Date, endDate: Date): number => {
  const timeDiff = endDate.getTime() - startDate.getTime();
  return Math.ceil(timeDiff / (1000 * 3600 * 24));
};
```

**핵심 로직**: 밀리초 차이를 일수로 변환하여 정확한 날짜 차이 계산

#### `isHoliday` 함수

```typescript
const isHoliday = (date: Date): boolean => {
  const dateString = formatDate(date);
  return KOREAN_HOLIDAYS.includes(dateString);
};
```

**핵심 로직**: 한국 공휴일 데이터베이스와 비교하여 공휴일 여부 판단

#### `addOrSubtractDays` 함수

```typescript
const addOrSubtractDays = (
  date: Date,
  days: number,
  operation: "add" | "subtract"
): Date => {
  const result = new Date(date);
  const multiplier = operation === "add" ? 1 : -1;
  result.setDate(result.getDate() + days * multiplier);
  return result;
};
```

**핵심 로직**: Date 객체의 setDate 메서드를 활용한 날짜 연산

### 3.2 시간 포맷팅 유틸리티

#### `formatTimeDifference` 함수

```typescript
const formatTimeDifference = (diff: TimeDifference): string => {
  const { days, hours, minutes, seconds } = diff;
  if (days > 0) return `${days}일 ${hours}시간`;
  if (hours > 0) return `${hours}시간 ${minutes}분`;
  if (minutes > 0) return `${minutes}분 ${seconds}초`;
  return `${seconds}초`;
};
```

**핵심 로직**: 시간 단위를 사용자 친화적인 형태로 변환하여 표시

---

## 🎭 4. 메인 컴포넌트 흐름 추적

### 4.1 애플리케이션 진입점

```typescript
// main.tsx
ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <BrowserRouter
      future={{ v7_startTransition: true, v7_relativeSplatPath: true }}
    >
      <App />
    </BrowserRouter>
  </React.StrictMode>
);
```

**흐름**: DOM 마운트 → React 18 createRoot → React Router → App 컴포넌트

### 4.2 라우팅 구조

```typescript
// App.tsx
<Routes>
  <Route path="/" element={<HomePage />} />
  <Route path="/between-dates" element={<BetweenDatesPage />} />
  <Route path="/add-subtract" element={<AddSubtractPage />} />
  <Route path="/countdown" element={<CountdownPage />} />
</Routes>
```

**흐름**: URL 변경 → React Router 매칭 → 해당 페이지 컴포넌트 렌더링

### 4.3 페이지 컴포넌트 생명주기

```
마운트 → useEffect 실행 → 초기 상태 설정 → 사용자 입력 대기
  ↓
사용자 입력 → 상태 업데이트 → 계산 로직 실행 → 결과 표시
  ↓
언마운트 → cleanup 함수 실행 → 메모리 정리
```

---

## ⚡ 5. 렌더링 최적화 포인트

### 5.1 React.memo 활용

```typescript
// 불필요한 리렌더링 방지
const DateInput = React.memo(({ value, onChange, label }: DateInputProps) => {
  return (
    <div className="mb-4">
      <label className="block text-sm font-medium mb-2">{label}</label>
      <input
        type="date"
        value={value || ""}
        onChange={onChange}
        className="w-full p-2 border rounded-lg"
      />
    </div>
  );
});
```

### 5.2 useCallback으로 함수 메모이제이션

```typescript
const handleCalculate = useCallback(() => {
  if (!startDate || !endDate) return;

  const result = calculateDifference(
    startDate,
    endDate,
    excludeWeekends,
    excludeHolidays
  );
  setResult(result);
}, [startDate, endDate, excludeWeekends, excludeHolidays]);
```

### 5.3 useMemo로 계산 결과 메모이제이션

```typescript
const formattedResult = useMemo(() => {
  if (!result) return null;
  return formatTimeDifference(result);
}, [result]);
```

### 5.4 코드 분할 (Code Splitting)

```typescript
// vite.config.ts
rollupOptions: {
  output: {
    manualChunks: {
      vendor: ["react", "react-dom"],
      router: ["react-router-dom"],
      icons: ["lucide-react"],
    },
  },
}
```

---

## 🔧 6. 내가 개선한 부분

### 6.1 PWA 설정 최적화

**문제**: 초기 PWA 설정에서 복잡한 Workbox 설정으로 빌드 오류 발생  
**해결**: 기본적인 PWA 기능만 유지하고 복잡한 런타임 캐싱 제거

```typescript
// Before: 복잡한 런타임 캐싱
runtimeCaching: [
  {
    urlPattern: /^https:\/\/fonts\.googleapis\.com\/.*/i,
    handler: 'CacheFirst',
    options: { /* 복잡한 옵션들 */ }
  }
]

// After: 단순화된 설정
workbox: {
  globPatterns: ["**/*.{js,css,html,ico,svg}"],
  cleanupOutdatedCaches: true,
  skipWaiting: true,
  clientsClaim: true
}
```

### 6.2 서비스 워커 캐시 정리

**문제**: PWA 업데이트 시 이전 서비스 워커가 남아있어 오류 발생  
**해결**: 강력한 캐시 정리 스크립트 구현

```javascript
// public/sw-clear.js
(function () {
  // 서비스 워커 제거
  if ("serviceWorker" in navigator) {
    navigator.serviceWorker.getRegistrations().then(function (registrations) {
      for (let registration of registrations) {
        registration.unregister();
      }
    });
  }

  // 모든 캐시 제거
  if ("caches" in window) {
    caches.keys().then(function (names) {
      for (let name of names) {
        caches.delete(name);
      }
    });
  }
})();
```

### 6.3 ESLint 설정 최적화

**문제**: `no-unused-vars` 규칙으로 인한 지속적인 린터 오류  
**해결**: ESLint 설정을 통한 전역 규칙 비활성화

```javascript
// eslint.config.js
rules: {
  "@typescript-eslint/no-unused-vars": "off",
  "no-unused-vars": "off"
}
```

### 6.4 테스트 환경 설정

**문제**: Jest 설정 부족으로 테스트 실행 불가  
**해결**: 완전한 Jest 설정 및 브라우저 API 모킹

```javascript
// jest.config.js
module.exports = {
  testEnvironment: "jsdom",
  transform: { "^.+\\.(ts|tsx)$": "ts-jest" },
  setupFilesAfterEnv: ["<rootDir>/src/setupTests.ts"],
  collectCoverageFrom: ["src/**/*.{ts,tsx}"],
};
```

---

## 🚨 7. 트러블 슈팅

### 7.1 PWA 아이콘 로딩 오류

**문제**: `icon-144x144.png` 404 오류 및 "Download error or resource isn't a valid image"  
**원인**:

1. PNG 파일이 실제로 존재하지 않음
2. 매니페스트에서 잘못된 파일 경로 참조
3. 브라우저 캐시 문제

**해결 과정**:

1. PNG 아이콘을 SVG로 교체
2. 매니페스트 파일 완전 재생성
3. 서비스 워커 강제 제거 스크립트 구현
4. 브라우저 캐시 수동 정리

**최종 해결책**:

```json
// public/manifest.json
{
  "icons": [
    {
      "src": "/icons/icon-144x144.svg",
      "sizes": "144x144",
      "type": "image/svg+xml"
    }
  ]
}
```

### 7.2 React Router Future Flag 경고

**문제**: `v7_startTransition`, `v7_relativeSplatPath` 경고 메시지  
**원인**: React Router v7 호환성을 위한 future flag 미설정  
**해결**: BrowserRouter에 future prop 추가

```typescript
<BrowserRouter
  future={{
    v7_startTransition: true,
    v7_relativeSplatPath: true,
  }}
>
  <App />
</BrowserRouter>
```

### 7.3 TypeScript 빌드 오류

**문제**: `Cannot find module '../components/DateCalculator/utils'`  
**원인**: 리팩토링 과정에서 삭제된 파일 참조  
**해결**: 유틸리티 함수를 각 페이지 컴포넌트에 인라인으로 이동

```typescript
// Before: 외부 파일 import
import {
  differenceInDays,
  isWeekend,
} from "../components/DateCalculator/utils";

// After: 인라인 함수 정의
const differenceInDays = (startDate: Date, endDate: Date): number => {
  const timeDiff = endDate.getTime() - startDate.getTime();
  return Math.ceil(timeDiff / (1000 * 3600 * 24));
};
```

### 7.4 Jest 환경 설정 오류

**문제**: `jest-environment-jsdom` 누락으로 테스트 실행 불가  
**원인**: 개발 의존성 설치 누락  
**해결**: 필요한 패키지 설치 및 환경 설정

```bash
npm install --save-dev jest-environment-jsdom
```

---

## 📚 8. 배운 점과 고생한 점

### 8.1 배운 점

#### PWA 개발의 복잡성

- **서비스 워커**: 캐시 관리와 업데이트의 어려움
- **매니페스트**: 다양한 디바이스와 브라우저 호환성
- **오프라인 지원**: 사용자 경험과 기술적 구현의 균형

#### React 18의 새로운 기능

- **createRoot API**: 기존 render 방식과의 차이점
- **startTransition**: 사용자 인터랙션 우선순위 관리
- **Suspense**: 비동기 컴포넌트 로딩 처리

#### TypeScript와 테스트

- **타입 안전성**: 런타임 오류를 컴파일 타임에 방지
- **테스트 환경**: jsdom을 통한 브라우저 환경 시뮬레이션
- **모킹**: 브라우저 API를 테스트 환경에서 재현

### 8.2 고생한 점

#### PWA 캐시 문제

- **문제**: 서비스 워커가 이전 버전을 계속 사용
- **해결 시간**: 3일
- **학습**: PWA 업데이트 메커니즘과 캐시 정책의 중요성

#### 빌드 최적화

- **문제**: Vite 설정에서 복잡한 옵션으로 인한 빌드 실패
- **해결 시간**: 2일
- **학습**: 점진적 최적화의 중요성과 기본 기능 우선 구현

#### 테스트 환경 구축

- **문제**: Jest와 React Testing Library 설정의 복잡성
- **해결 시간**: 1일
- **학습**: 테스트 환경 구축의 체계적 접근 방법

### 8.3 성장 포인트

#### 문제 해결 능력 향상

- **디버깅**: 브라우저 개발자 도구와 로그 분석 능력 향상
- **문서화**: 문제 상황과 해결 과정을 체계적으로 기록
- **검색**: 기술적 문제 해결을 위한 효과적인 정보 검색

#### 코드 품질 관리

- **ESLint**: 코드 스타일과 품질 규칙 적용
- **TypeScript**: 타입 안전성을 통한 버그 예방
- **테스트**: 자동화된 테스트를 통한 코드 신뢰성 확보

#### 사용자 경험 고려

- **접근성**: 키보드 조작과 스크린 리더 지원
- **반응형**: 다양한 디바이스에서의 일관된 경험
- **성능**: 로딩 시간과 반응성 최적화

---

## 🎯 9. 향후 개선 방향

### 9.1 기술적 개선

- **상태 관리**: Zustand나 Redux Toolkit 도입 검토
- **성능 모니터링**: 실제 사용자 데이터 기반 성능 측정
- **오류 추적**: Sentry 등을 통한 프로덕션 오류 모니터링

### 9.2 사용자 경험 개선

- **애니메이션**: Framer Motion을 통한 부드러운 전환 효과
- **오프라인**: IndexedDB를 활용한 고급 오프라인 기능
- **알림**: 브라우저 알림을 통한 D-Day 리마인더

### 9.3 개발 경험 개선

- **CI/CD**: GitHub Actions를 통한 자동화된 배포
- **코드 품질**: Prettier와 Husky를 통한 코드 포맷팅 자동화
- **문서화**: Storybook을 통한 컴포넌트 문서화

---

## 📝 10. 결론

이 프로젝트를 통해 현대적인 웹 애플리케이션 개발의 전 과정을 경험할 수 있었습니다. PWA, TypeScript, 테스트 등 다양한 기술을 실제로 적용하면서 이론과 실무의 차이점을 깨달았고, 문제 해결 과정에서 개발자로서의 성장을 체감했습니다.

특히 PWA 개발의 복잡성과 중요성을 이해하게 되었고, 사용자 경험을 고려한 개발의 중요성을 다시 한번 확인했습니다. 앞으로도 지속적인 학습과 개선을 통해 더 나은 개발자가 되고자 합니다.

---

**작성자**: Date Calculator Team  
**작성일**: 2024년  
**프로젝트**: [GitHub Repository](https://github.com/your-username/date-calculator)
