# 기술블로그: React + TypeScript + Tailwind CSS로 구현한 정규표현식 테스터

## 📝 프로젝트 소개
정규표현식을 실시간으로 테스트하고 학습할 수 있는 웹 애플리케이션을 React, TypeScript, Tailwind CSS를 사용하여 개발했습니다. 이 글에서는 프로젝트의 기술적 구현과 아키텍처, 그리고 개발 과정에서 겪은 문제들과 해결 방법을 공유합니다.

## 🏗️ 1. 프로젝트 구조 분석

### 1.1 전체 아키텍처
```
regex-tester/
├── src/
│   ├── components/
│   │   └── RegexTester/
│   │       ├── index.tsx      # 메인 컴포넌트
│   │       ├── types.ts       # 타입 정의
│   │       └── utils.ts       # 유틸리티 함수
│   ├── hooks/
│   │   ├── useLocalStorage.ts # 로컬 스토리지 훅
│   │   ├── useClipboard.ts    # 클립보드 훅
│   │   └── useDarkMode.ts     # 다크모드 훅
│   ├── utils/
│   │   └── common.ts          # 공통 유틸리티
│   ├── App.tsx                # 앱 루트
│   └── main.tsx               # 진입점
├── package.json
├── tailwind.config.cjs
├── vite.config.ts
└── tsconfig.json
```

### 1.2 기술 스택 선택 이유
- **React**: 컴포넌트 기반 아키텍처로 재사용 가능한 UI 구성
- **TypeScript**: 타입 안전성과 개발자 경험 향상
- **Tailwind CSS**: 유틸리티 퍼스트 CSS로 빠른 스타일링과 일관성
- **Vite**: 빠른 개발 서버와 빌드 성능
- **localStorage**: 서버 없이도 데이터 영속성 보장

## 🔄 2. 상태 관리 흐름 추적

### 2.1 상태 구조 설계
```typescript
// 메인 상태들
const [pattern, setPattern] = useLocalStorage<string>('regexTester:pattern', '');
const [flags, setFlags] = useLocalStorage<string>('regexTester:flags', 'g');
const [testText, setTestText] = useLocalStorage<string>('regexTester:testText', '');
const [replacement, setReplacement] = useLocalStorage<string>('regexTester:replacement', '');

// 파생 상태들
const [matches, setMatches] = useState<MatchResult[]>([]);
const [segments, setSegments] = useState<{ text: string; matchIndex: number | null }[]>([]);
const [description, setDescription] = useState<TokenDescription[]>([]);
```

### 2.2 상태 업데이트 흐름
1. **사용자 입력** → `pattern`, `flags`, `testText` 변경
2. **useEffect 트리거** → 정규식 컴파일 및 실행
3. **결과 계산** → `matches`, `segments`, `description` 업데이트
4. **UI 렌더링** → 변경된 상태에 따른 화면 업데이트

### 2.3 상태 지속성 전략
- **localStorage 훅**: 사용자 입력을 자동으로 저장하여 새로고침 시 복원
- **세션 간 데이터 유지**: 패턴, 플래그, 테스트 텍스트 등 핵심 데이터 보존
- **저장된 패턴**: 자주 사용하는 정규식을 최대 20개까지 저장

## 🔧 3. 중요 유틸 함수 하나씩 이해

### 3.1 `buildRegex` - 정규식 컴파일
```typescript
export function buildRegex(pattern: string, flags: string): RegExp | null {
  try {
    return new RegExp(pattern, flags);
  } catch {
    return null;
  }
}
```
**핵심**: try-catch로 잘못된 정규식 구문을 안전하게 처리하고, 컴파일 실패 시 null 반환

### 3.2 `getMatches` - 매치 결과 추출
```typescript
export function getMatches(regex: RegExp, text: string): MatchResult[] {
  const results: MatchResult[] = [];
  const regexCopy = new RegExp(regex.source, regex.flags);
  regexCopy.lastIndex = 0;
  
  if (regexCopy.global) {
    while ((match = regexCopy.exec(text)) !== null) {
      results.push({
        match: match[0],
        index: match.index,
        groups: match.slice(1),
      });
    }
  }
  return results;
}
```
**핵심**: 원본 정규식을 복사하여 `lastIndex` 상태 오염 방지, 전역 플래그에 따른 반복 매치

### 3.3 `describePattern` - 패턴 파싱
```typescript
export function describePattern(pattern: string): TokenDescription[] {
  const tokens: TokenDescription[] = [];
  let i = 0;
  
  while (i < pattern.length) {
    let token = pattern[i];
    if (token === '\\' && i < pattern.length - 1) {
      token = pattern.slice(i, i + 2);
      i += 2;
    } else {
      i++;
    }
    const desc = TOKEN_DESCRIPTIONS[token] || `리터럴 '${token}'`;
    tokens.push({ token, description: desc });
  }
  return tokens;
}
```
**핵심**: 이스케이프 시퀀스를 2문자 토큰으로 처리하고, 각 토큰에 대한 설명 매핑

## 🎯 4. 메인 컴포넌트 흐름 추적

### 4.1 컴포넌트 생명주기
```typescript
const RegexTester: React.FC = () => {
  // 1. 상태 초기화 (localStorage에서 복원)
  const [pattern, setPattern] = useLocalStorage<string>('regexTester:pattern', '');
  
  // 2. 사이드 이펙트 (패턴 변경 시 자동 실행)
  useEffect(() => {
    if (!pattern.trim()) return;
    
    const regex = buildRegex(pattern, flags);
    if (!regex) {
      setRegexError('Invalid regular expression');
      return;
    }
    
    const results = getMatches(regex, testText);
    setMatches(results);
    setDescription(describePattern(pattern));
  }, [pattern, flags, testText, replacement]);
  
  // 3. 이벤트 핸들러들
  const toggleFlag = (flag: string) => { /* ... */ };
  const saveCurrentPattern = () => { /* ... */ };
  
  // 4. 렌더링
  return (/* JSX */);
};
```

### 4.2 데이터 흐름
1. **입력** → 사용자가 정규식 패턴 입력
2. **검증** → `buildRegex`로 구문 검증
3. **실행** → `getMatches`로 매치 결과 계산
4. **분석** → `describePattern`으로 패턴 설명 생성
5. **표시** → 결과를 UI에 렌더링

## ⚡ 5. 렌더링 최적화 포인트

### 5.1 메모이제이션 전략
```typescript
// useCallback으로 함수 재생성 방지
const handleCopy = useCallback(async () => {
  if (!replaceOutput) return;
  try {
    await copy(replaceOutput);
    setToast({ message: 'Copied to clipboard!', type: 'success' });
  } catch {
    setToast({ message: 'Copy failed', type: 'error' });
  }
}, [replaceOutput, copy]);
```

### 5.2 조건부 렌더링 최적화
```typescript
// 불필요한 렌더링 방지
{pattern.length === 0 && (
  <li className="text-gray-500 dark:text-gray-400">
    패턴을 입력하면 설명을 볼 수 있습니다
  </li>
)}

{matches.length === 0 && (
  <li className="p-2 text-gray-500 dark:text-gray-400">
    일치 항목이 없습니다
  </li>
)}
```

### 5.3 상태 업데이트 최적화
- **배치 업데이트**: 관련 상태들을 한 번에 업데이트하여 불필요한 리렌더링 방지
- **조건부 실행**: 빈 패턴일 때는 정규식 실행을 건너뛰어 성능 향상

## 🚀 6. 내가 개선한 부분

### 6.1 정규식 상태 오염 방지
**문제**: 원본 정규식의 `lastIndex` 속성이 수정되어 상태 오염 발생
**해결**: `new RegExp(regex.source, regex.flags)`로 복사본 생성하여 원본 보호

### 6.2 다크모드 시각적 일관성
**문제**: 다크모드에서 입력 필드가 흰색으로 표시되고 일부 텍스트가 보이지 않음
**해결**: 모든 UI 요소에 `dark:` 클래스 추가하여 일관된 다크모드 지원

### 6.3 한글화 및 접근성 향상
**문제**: 영어 UI로 인한 한국 사용자 접근성 저하
**해결**: 모든 UI 텍스트를 한글로 번역하고, 플래그 옵션에 상세한 설명 추가

### 6.4 에러 처리 강화
**문제**: 정규식 컴파일 실패 시 적절한 에러 메시지 부재
**해결**: try-catch로 구문 오류를 포착하고 사용자 친화적 메시지 표시

## 🐛 7. 트러블 슈팅

### 7.1 브라우저 자동 번역 문제
**증상**: Chrome의 한국어/영어 자동 번역으로 인해 플래그 체크박스가 한글로 표시
**원인**: 브라우저의 자동 번역 기능이 HTML 콘텐츠를 번역
**해결**: 
```html
<html translate="no">
<meta name="google" content="notranslate">
```
CSS에도 `* { translate: no; }` 추가

### 7.2 정규식 lastIndex 상태 오염
**증상**: 전역 플래그 사용 시 매치 결과가 예상과 다르게 동작
**원인**: `regex.exec()` 호출 시 `lastIndex` 속성이 수정되어 상태 오염
**해결**: 정규식을 복사하여 원본 보호
```typescript
const regexCopy = new RegExp(regex.source, regex.flags);
regexCopy.lastIndex = 0;
```

### 7.3 다크모드 렌더링 문제
**증상**: 다크모드에서 일부 UI 요소가 보이지 않거나 색상이 부적절
**원인**: Tailwind CSS의 다크모드 클래스가 일부 요소에 누락
**해결**: 모든 입력 필드, 텍스트, 배경에 `dark:` 클래스 체계적 적용

### 7.4 TypeScript 타입 안전성
**증상**: localStorage 관련 타입 오류와 undefined 처리 문제
**원인**: 제네릭 타입과 함수형 업데이트의 타입 추론 한계
**해결**: 명시적 타입 정의와 타입 가드 추가

## 📚 8. 배운 점과 고생한 점

### 8.1 배운 점

#### React Hooks 최적화
- **useCallback**: 함수 재생성 방지로 불필요한 리렌더링 최소화
- **useEffect 의존성**: 정확한 의존성 배열 관리의 중요성
- **커스텀 훅**: 로직 재사용과 관심사 분리의 효과

#### 정규식 처리
- **상태 관리**: 정규식 객체의 상태 오염 방지 방법
- **성능 최적화**: 대용량 텍스트에서의 효율적인 매치 처리
- **에러 처리**: 잘못된 정규식 구문에 대한 안전한 처리

#### Tailwind CSS 활용
- **다크모드**: 체계적인 다크모드 클래스 적용 방법
- **반응형 디자인**: 유틸리티 클래스를 활용한 반응형 레이아웃
- **커스터마이징**: 설정 파일을 통한 디자인 시스템 구축

### 8.2 고생한 점

#### 브라우저 호환성
- **자동 번역**: 크로스 브라우저에서 일관된 동작 보장의 어려움
- **localStorage**: 일부 브라우저에서의 제한사항과 에러 처리
- **CSS 호환성**: 다양한 브라우저에서의 다크모드 지원

#### 상태 관리 복잡성
- **비동기 처리**: 클립보드 API와 localStorage의 비동기 동작
- **상태 동기화**: 여러 상태 간의 의존성과 업데이트 순서
- **메모리 누수**: 이벤트 리스너와 타이머의 적절한 정리

#### 사용자 경험 최적화
- **실시간 피드백**: 입력과 동시에 결과를 표시하는 UX 설계
- **에러 처리**: 사용자가 이해할 수 있는 에러 메시지 작성
- **접근성**: 키보드 네비게이션과 스크린 리더 지원

## 🎯 결론

이 프로젝트를 통해 React와 TypeScript를 활용한 실용적인 웹 애플리케이션 개발 경험을 쌓을 수 있었습니다. 특히 정규식 처리, 상태 관리, 다크모드 지원 등 다양한 기술적 도전과제를 해결하면서 프론트엔드 개발에 대한 이해도를 크게 향상시킬 수 있었습니다.

가장 중요한 것은 **사용자 경험을 고려한 설계**와 **코드 품질과 유지보수성의 균형**이었다는 점입니다. 기능 구현에만 집중하지 않고, 에러 처리, 접근성, 성능 최적화까지 고려한 개발 과정이 매우 유익했습니다.

앞으로도 이러한 경험을 바탕으로 더 나은 사용자 경험을 제공하는 웹 애플리케이션을 개발하고 싶습니다.