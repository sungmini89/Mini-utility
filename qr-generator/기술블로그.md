# QR 코드 생성기 개발기: React + TypeScript + Tailwind CSS로 만든 현대적 웹 앱

## 📝 프로젝트 소개

QR 코드 생성기는 다양한 데이터 타입을 QR 코드로 변환하고 커스터마이징할 수 있는 웹 애플리케이션입니다. React 18, TypeScript, Tailwind CSS를 기반으로 개발되었으며, PWA 지원과 다크모드를 포함한 현대적인 사용자 경험을 제공합니다.

**🔗 프로젝트**: [GitHub Repository]  
**🛠️ 기술 스택**: React 18 + TypeScript + Vite + Tailwind CSS  
**📱 특징**: PWA 지원, 다크모드, 반응형 디자인, 키보드 단축키

---

## 1. 프로젝트 구조 분석

### 1.1 폴더 구조

```
src/
├── components/
│   └── QrGenerator/
│       ├── index.tsx      # 메인 컴포넌트
│       ├── types.ts       # 타입 정의
│       └── utils.ts       # 유틸리티 함수
├── hooks/
│   ├── useLocalStorage.ts # localStorage 훅
│   ├── useDarkMode.ts     # 다크모드 훅
│   └── useClipboard.ts    # 클립보드 훅
├── pages/
│   └── QrGeneratorPage.tsx # 페이지 래퍼
├── utils/
│   └── common.ts          # 공통 유틸리티
├── App.tsx                # 메인 레이아웃
├── main.tsx               # 진입점
└── router.tsx             # 라우터 설정
```

### 1.2 아키텍처 패턴

- **컴포넌트 기반**: 재사용 가능한 UI 컴포넌트
- **커스텀 훅**: 비즈니스 로직 분리
- **타입 안전성**: TypeScript로 런타임 에러 방지
- **상태 관리**: React 내장 상태 + localStorage 영속성

---

## 2. 상태 관리 흐름 추적

### 2.1 상태 구조

```typescript
// 메인 상태들
const [activeType, setActiveType] = useState<QrType>("text");
const [qrValue, setQrValue] = useState<string>("");
const [size, setSize] = useLocalStorage<number>("qrGenerator:size", 256);
const [fgColor, setFgColor] = useLocalStorage<string>(
  "qrGenerator:fgColor",
  "#000000"
);
const [bgColor, setBgColor] = useLocalStorage<string>(
  "qrGenerator:bgColor",
  "#ffffff"
);
const [logoData, setLogoData] = useLocalStorage<string | undefined>(
  "qrGenerator:logo",
  undefined
);
const [history, setHistory] = useLocalStorage<HistoryItem[]>(
  "qrGenerator:history",
  []
);
```

### 2.2 상태 흐름도

```
사용자 입력 → 상태 업데이트 → useEffect → QR 값 계산 → 히스토리 저장
    ↓
localStorage 동기화 → UI 업데이트 → 사용자 피드백
```

### 2.3 상태 지속성 전략

- **useLocalStorage 훅**: 자동 localStorage 동기화
- **에러 복구**: 잘못된 데이터 자동 정리
- **SSR 안전성**: 서버 사이드에서 안전한 기본값 반환

---

## 3. 중요 유틸 함수 하나씩 이해

### 3.1 QR 코드 데이터 생성 함수들

#### `generateText(text: string)`

```typescript
export function generateText(text: string): string {
  return text.trim();
}
```

- **목적**: 텍스트 전처리 (공백 제거)
- **특징**: 단순하지만 일관성 있는 데이터 처리

#### `generateUrl(url: string)`

```typescript
export function generateUrl(url: string): string {
  const trimmed = url.trim();
  if (!trimmed) return "";
  if (/^https?:\/\//i.test(trimmed)) {
    return trimmed;
  }
  return `https://${trimmed}`;
}
```

- **목적**: URL 프로토콜 자동 추가
- **특징**: 사용자 편의성 향상, 정규식 활용

#### `generateWifi(wifiInput: WifiInput)`

```typescript
export function generateWifi({
  ssid,
  password,
  encryption,
  hidden,
}: WifiInput): string {
  const esc = (s: string) => s.replace(/([\\;:,\"])/g, "\\$1");
  const enc = encryption === "nopass" ? "" : encryption;
  const parts = [
    `WIFI:T:${enc};` +
      `S:${esc(ssid)};` +
      (encryption !== "nopass" ? `P:${esc(password)};` : "") +
      (hidden ? "H:true;" : "") +
      ";",
  ];
  return parts.join("");
}
```

- **목적**: WiFi Alliance 표준 준수
- **특징**: 특수문자 이스케이프, 조건부 필드 포함

### 3.2 이미지 처리 함수들

#### `svgToPng(svgElement: SVGSVGElement, scale = 1)`

```typescript
export async function svgToPng(
  svgElement: SVGSVGElement,
  scale = 1
): Promise<string> {
  const svgString = new XMLSerializer().serializeToString(svgElement);
  const blob = new Blob([svgString], { type: "image/svg+xml" });
  const url = URL.createObjectURL(blob);
  const img = new Image();

  return new Promise((resolve, reject) => {
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (!ctx) throw new Error("Canvas not supported");

      ctx.drawImage(img, 0, 0, width, height);
      const pngData = canvas.toDataURL("image/png");
      URL.revokeObjectURL(url);
      resolve(pngData);
    };
    img.onerror = reject;
    img.src = url;
  });
}
```

- **목적**: SVG를 PNG로 변환
- **특징**: Canvas API 활용, 메모리 관리, Promise 기반

---

## 4. 메인 컴포넌트 흐름 추적

### 4.1 컴포넌트 생명주기

```typescript
const QrGenerator: React.FC = () => {
  // 1. 상태 초기화
  const [activeType, setActiveType] = useState<QrType>("text");
  const [qrValue, setQrValue] = useState<string>("");

  // 2. localStorage에서 설정 로드
  const [size, setSize] = useLocalStorage<number>("qrGenerator:size", 256);

  // 3. QR 값 자동 계산
  useEffect(() => {
    let value = "";
    try {
      switch (activeType) {
        case "text":
          value = generateText(textInput.text);
          break;
        case "url":
          value = generateUrl(urlInput.url);
          break;
        // ... 기타 케이스
      }
    } catch (err) {
      console.error(err);
      setToast({ message: "Error generating QR value", type: "error" });
    }
    setQrValue(value);
  }, [activeType, textInput, urlInput /* ... */]);

  // 4. 히스토리 자동 저장
  useEffect(() => {
    if (!qrValue) return;
    const newItem: HistoryItem = {
      type: activeType,
      data: qrValue,
      date: Date.now(),
    };
    setHistory((prev) => {
      // 중복 방지 로직
      if (
        prev.length > 0 &&
        prev[0].data === qrValue &&
        prev[0].type === activeType
      ) {
        return prev;
      }
      return [newItem, ...prev.slice(0, 9)]; // 최근 10개만 유지
    });
  }, [qrValue, activeType]);

  // 5. 키보드 이벤트 처리
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Alt+1~6: 탭 전환
      if (e.altKey && e.key >= "1" && e.key <= "6") {
        const num = parseInt(e.key);
        if (num >= 1 && num <= 6) {
          e.preventDefault();
          const types: QrType[] = [
            "text",
            "url",
            "wifi",
            "vcard",
            "email",
            "sms",
          ];
          setActiveType(types[num - 1]);
        }
      }
      // Ctrl+Shift+C: 복사
      if (
        (e.ctrlKey || e.metaKey) &&
        e.shiftKey &&
        e.key.toLowerCase() === "c"
      ) {
        e.preventDefault();
        handleCopy();
      }
      // ... 기타 단축키
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);

  // 6. 렌더링
  return (
    <div className="max-w-6xl mx-auto p-4">
      {/* 탭 네비게이션 */}
      {/* 입력 폼 */}
      {/* QR 코드 미리보기 */}
      {/* 액션 버튼 */}
      {/* 히스토리 */}
    </div>
  );
};
```

### 4.2 데이터 흐름

1. **사용자 입력** → 상태 업데이트
2. **useEffect 트리거** → QR 값 재계산
3. **QR 값 변경** → 히스토리 자동 저장
4. **UI 업데이트** → 사용자 피드백

---

## 5. 렌더링 최적화 포인트

### 5.1 메모이제이션 전략

```typescript
// 입력 폼 렌더링 최적화
const renderInputs = () => {
  switch (activeType) {
    case "text":
      return <TextInputForm />;
    case "url":
      return <UrlInputForm />;
    // ... 기타 케이스
  }
};

// 조건부 렌더링으로 불필요한 리렌더링 방지
{
  qrValue ? (
    <div className="relative" style={{ width: size, height: size }}>
      <QRCode value={qrValue} size={size} fgColor={fgColor} bgColor={bgColor} />
      {logoData && <LogoOverlay />}
    </div>
  ) : (
    <p className="text-gray-500">Enter data to generate a QR code.</p>
  );
}
```

### 5.2 상태 업데이트 최적화

- **배치 업데이트**: 여러 상태 변경을 하나의 리렌더링으로 처리
- **조건부 업데이트**: 불필요한 상태 변경 방지
- **참조 안정성**: 함수와 객체의 불필요한 재생성 방지

---

## 6. 내가 개선한 부분

### 6.1 localStorage 에러 처리 강화

```typescript
// 기존: 단순한 JSON.parse
const stored = window.localStorage.getItem(key);
return JSON.parse(stored) as T;

// 개선: 안전한 파싱과 에러 복구
try {
  const stored = window.localStorage.getItem(key);
  if (
    stored === null ||
    stored === undefined ||
    stored === "undefined" ||
    stored === ""
  ) {
    return defaultValue;
  }
  return JSON.parse(stored) as T;
} catch (error) {
  console.warn(
    "useLocalStorage: unable to parse stored value for key:",
    key,
    error
  );
  // 파싱 실패 시 해당 키 삭제
  try {
    window.localStorage.removeItem(key);
  } catch (removeError) {
    console.warn(
      "useLocalStorage: unable to remove invalid key:",
      key,
      removeError
    );
  }
  return defaultValue;
}
```

### 6.2 React Router Future Flags 설정

```typescript
// router.tsx에서 Future Flags 명시적 설정
const router = createBrowserRouter(
  [
    {
      path: "/",
      element: <App />,
      children: [{ index: true, element: <QrGeneratorPage /> }],
    },
  ],
  {
    future: {
      v7_startTransition: true,
      v7_relativeSplatPath: true,
    } as any,
  }
);
```

### 6.3 한국어 JSDoc 추가

- 모든 주요 함수와 컴포넌트에 상세한 한국어 설명
- 사용 예시와 매개변수 설명 포함
- 개발자 경험 향상

---

## 7. 트러블 슈팅

### 7.1 localStorage 파싱 에러

**문제**: `"undefined" is not valid JSON` 에러 발생  
**원인**: localStorage에 문자열 "undefined"가 저장됨  
**해결**: 파싱 전 유효성 검사 및 에러 복구 로직 추가

### 7.2 React Router Future Flags 경고

**문제**: v7 관련 경고 메시지 지속 발생  
**원인**: Future Flags가 제대로 설정되지 않음  
**해결**: createBrowserRouter에서 명시적 설정 및 TypeScript 타입 단언

### 7.3 Jest 설정 문제

**문제**: TypeScript 파일 파싱 실패  
**원인**: Jest 설정 파일 형식 및 의존성 문제  
**해결**: jest.config.cjs 생성, ts-jest 프리셋 설정, jsdom 환경 구성

### 7.4 HMR 설정 오류

**문제**: `__HMR_CONFIG_NAME__ is not defined` 에러  
**원인**: Vite HMR 설정 누락  
**해결**: vite.config.ts에 define 속성 추가

---

## 8. 배운 점과 고생한 점

### 8.1 배운 점

#### 🎯 TypeScript 활용

- **타입 안전성**: 런타임 에러 대폭 감소
- **인터페이스 설계**: 데이터 구조의 명확한 정의
- **제네릭 활용**: 재사용 가능한 타입 안전한 훅

#### 🔧 React 최신 기능

- **useEffect 의존성**: 정확한 의존성 배열 관리의 중요성
- **커스텀 훅**: 비즈니스 로직의 재사용성과 테스트 용이성
- **상태 관리**: 복잡한 상태를 단순한 로직으로 관리

#### 🎨 Tailwind CSS

- **유틸리티 클래스**: 빠른 스타일링과 일관성
- **반응형 디자인**: 모바일 퍼스트 접근법
- **다크모드**: CSS 변수와 클래스 기반 테마 전환

#### 🚀 Vite

- **빠른 개발 서버**: HMR과 빌드 속도 향상
- **플러그인 시스템**: PWA, React 등 플러그인 활용
- **환경 변수**: 개발/프로덕션 환경별 설정

### 8.2 고생한 점

#### 😰 localStorage 복잡성

- **데이터 무결성**: 잘못된 데이터로 인한 앱 크래시
- **브라우저 호환성**: 다양한 브라우저의 localStorage 동작 차이
- **에러 복구**: 사용자 경험을 해치지 않는 에러 처리

#### 😤 React Router 설정

- **Future Flags**: v7 마이그레이션 준비의 복잡성
- **TypeScript 타입**: 라이브러리 타입 정의와의 불일치
- **라우팅 구조**: SPA에서의 적절한 라우팅 설계

#### 😵 Jest 테스트 환경

- **환경 설정**: Node.js와 브라우저 환경의 차이
- **모킹**: localStorage, navigator.clipboard 등 브라우저 API 모킹
- **TypeScript 통합**: Jest와 TypeScript의 설정 복잡성

### 8.3 성장 포인트

#### 💪 문제 해결 능력

- **체계적 접근**: 에러 로그 분석부터 해결까지의 과정
- **디버깅 기술**: 브라우저 개발자 도구와 로깅 활용
- **문서화**: 문제와 해결책을 체계적으로 기록

#### 🧠 기술적 이해도

- **React 생명주기**: 컴포넌트의 동작 원리 깊이 이해
- **상태 관리**: 복잡한 상태 흐름의 설계와 최적화
- **성능 최적화**: 불필요한 리렌더링 방지와 메모리 관리

---

## 🎉 결론

QR 코드 생성기 프로젝트를 통해 현대적인 웹 개발의 전 과정을 경험했습니다. React 18의 최신 기능부터 TypeScript의 타입 안전성, Tailwind CSS의 효율적인 스타일링까지 다양한 기술을 실무에 적용해볼 수 있었습니다.

특히 **사용자 경험**과 **코드 품질**을 동시에 고려한 개발 과정에서 많은 인사이트를 얻었고, **트러블 슈팅** 과정을 통해 문제 해결 능력도 크게 향상되었습니다.

앞으로도 이런 현대적인 웹 개발 기술들을 활용하여 더 나은 사용자 경험을 제공하는 애플리케이션을 만들어가고 싶습니다! 🚀

---

**📚 참고 자료**

- [React 공식 문서](https://react.dev/)
- [TypeScript 핸드북](https://www.typescriptlang.org/docs/)
- [Tailwind CSS 문서](https://tailwindcss.com/docs)
- [Vite 가이드](https://vitejs.dev/guide/)
- [React Router 문서](https://reactrouter.com/)
